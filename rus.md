# Пишем тестируемый JavaScript

У всех наступал момент, когда скрипт, состоявший из нескольких
строк кода разрастался до тысячи, затем до двух, дальше — больше.
Постепенно функция начинает принимать чуть больше параметров; Условные операторы
немножко усложняются. И в один прекрасный день появляется баг: что-то ломается.
И нам предстоит распутать весь этот бардак.

Сейчас код на фронтенде берёт на себя всё больше и больше ответственности — на
самом деле, уже существует целый пласт приложений, существующих полностью на
клиентской стороне — в связи со всем этим становятся очевидными две идеи. Первая — мы
просто не можем прокликать все возможные варианты с помощью текущего метода
тестирования. Вторая — возможно, нам потребуется изменить подход к тому, как
мы привыкли писать код, в пользу возможности писать тесты.

Действительно ли нам необходимо изменить подход к написанию кода? Да, ведь даже
если мы понимаем пользу автоматического тестирования, большинство из нас могут
написать максимум интеграционные тесты. Они важны, так как позволяют понять, насколько
согласованна работа разных частей приложения, но чего они не показывают, так это
**работают ли независимые части приложения именно так, как ожидается**.

Именно для этого нужны модульные тесты. И нам будет очень сложно писать их до
тех пор, пока мы не начнем писать *пригодный для тестирования JavaScript*.

## Модульные и интеграционные тесты: в чём разница?

Обычно способ создания интеграционных тестов достаточно прост: мы пишем код,
описывающий, как пользователь взаимодействует с нашим приложением, и то, что
пользователь ожидает увидеть в результате своих действий. Популярным средством
автоматического тестирования является [Selenium][1]. [Capybara][2] для Ruby облегчает
взаимодействие с Selenium, более того, существуют тысячи подобных инструментов на
других языках.

Ниже представлен интеграционный тест для небольшой части поискового приложения:

    def test_search
      fill_in('q', :with => 'cat')
      find('.btn').click
      assert( find('#results li').has_content?('cat'), 'Результаты поиска отображены' )
      assert( page.has_no_selector?('#results li.no-results'), 'Результаты поиска отсутствуют' )
    end

В то время как интеграционный тест охватывает взаимодействие пользователя с
приложением в целом, модульный тест охватывает только небольшой блок кода:

> Если я вызову функцию с определенными аргументами, то получу ли я ожидаемый
результат?

Приложения, написанные в традиционном процедурном стиле, может быть очень сложно
покрыть модульными тестами, поддерживать и отлаживать, они обладают низкой
расширяемостью. Но если мы будем писать код с учетом необходимости его покрытия
модульными тестами, это не только упростит написание тестов, но и *улучшит
качество кода* в целом.

Что бы понять о чем идет речь, давайте рассмотрим простое поисковое приложение:

![Скриншот][Поисковое приложение]

Когда пользователь вводит поисковый запрос, приложение отправляет XHR-запрос
серверу. Когда сервер возвращает данные, соответствующие запросу, в формате JSON,
приложение, используя шаблонизатор на клиенте, выводит их на страницу. Пользователь
может кликнуть по элементу поисковой выдачи, чтобы показать, что он ему
понравился; в этом случае имя понравившегося человека добавляется в список
понравившихся, расположенный справа.

«Традиционная» реализация может выглядеть следующим образом:

    var tmplCache = {};

    function loadTemplate (name) {
      if (!tmplCache[name]) {
        tmplCache[name] = $.get('/templates/' + name);
      }
      return tmplCache[name];
    }

    $(function () {

      var resultsList = $('#results');
      var liked = $('#liked');
      var pending = false;

      $('#searchForm').on('submit', function (e) {
        e.preventDefault();

        if (pending) { return; }

        var form = $(this);
        var query = $.trim( form.find('input[name="q"]').val() );

        if (!query) { return; }

        pending = true;

        $.ajax('/data/search.json', {
          data : { q: query },
          dataType : 'json',
          success : function (data) {
            loadTemplate('people-detailed.tmpl').then(function (t) {
              var tmpl = _.template(t);
              resultsList.html( tmpl({ people : data.results }) );
              pending = false;
            });
          }
        });

        $('<li>', {
          'class' : 'pending',
          html : 'Идёт поиск…'
        }).appendTo( resultsList.empty() );
      });

      resultsList.on('click', '.like', function (e) {
        e.preventDefault();
        var name = $(this).closest('li').find('h2').text();
        liked.find('.no-results').remove();
        $('<li>', { text: name }).appendTo(liked);
      });

    });

Мой друг [Адама Сонтега][4] (Adam Sontag) называет это
«Выбери себе приключение» — в каждой строчке мы с равной вероятностью можем
иметь дело как с представлением, так и с информацией, обслуживанием логики
пользовательского взаимодействия или проверкой состояния приложения. Остаётся
только догадываться! Достаточно просто написать интеграционные тесты для такого
кода, и в тоже время очень сложно написать тесты для отдельных *функциональных
модулей*.

Почему это сложно? Для этого существуют четыре причины:

* Слабо выраженная структура; чаще всего всё происходит в коллбэке
`$(document).ready()` — и, так как это анонимная функция, её невозможно
протестировать ввиду невозможности к ней обратиться;
* слишком сложные функции; Если в функции больше 10 строк кода, как, например,
в обработчике отправки формы, то её, вероятно, можно упростить;
* скрытые состояния; так как состояние `pending` помещено в замыкание, то
нельзя проверить, правильно ли установлено это состояние;
* избыточная связанность функционала; к примеру, обработчик события `success`
запроса `$.ajax` не должен требовать непосредственного доступа к DOM.

## Организация кода

Первое, что необходимо сделать — выбрать менее запутанный метод организации кода и
разбить его на несколько зон ответственности:

* представление и взаимодействие с пользователем;
* управление данными;
* общее состояние приложения;
* настройка и написание кода, отвечающего за взаимодействие разных частей приложения;

В «традиционной» реализации, показанной выше, эти четыре категории не разделяются —
на одной строчке мы работаем с представлением, двумя строчками ниже мы делаем
запрос к серверу.

![Иллюстрация][Организация кода]

Несмотря на то, что мы, безусловно, можем покрыть такой код интеграционными
тестами (и нам стоит это сделать!), покрыть его модульными тестами будет
довольно сложно. При написании функциональных тестов мы можем утверждать: «когда
пользователь ищет что-то, он должен видеть соответствующие результаты», но не
более того. Если что-то пойдёт не так, нам следует определить, что именно пошло
не так, и функциональные тесты тут бесполезны.

Если мы переосмыслим то, как мы пишем код, то мы можем не только покрыть его
модульными-тестами, которые дадут нам представление о том, где ошибка, но и, в
конечном итоге, писать код, который проще поддерживать, расширять и использовать
повторно.

Давайте перепишем наш код согласно следующим принципам:

* каждый поведенческий аспект должен быть представлен отдельным объектом,
относящимся к одной из четырех областей ответственности и не зависящий от
других объектов. Это позволит избежать возникновения сильно-связанного кода;
* код должен быть легко настраиваем, а не зависеть от жестко заданных значений.
В этом случае мы сможем избежать воспроизведения в коде соответствующего HTML
окружения в процессе написания тестов;
* поддерживайте методы объектов простыми, с небольшим количеством кода. В
результате мы сможем писать короткие, простые и читабельные тесты;
* для создания экземпляров объекта используйте функцию-конструктор. Благодаря
этому мы сможем создавать для тестирования отдельный объект.

Для начала надо определиться, на какие части мы разобьём наше приложение. У нас
есть три части, относящиеся к представлению и взаимодействию: «поисковая форма»,
«поисковая выборка» и «понравившиеся результаты».

![Скриншот][Части приложения]

Также существует кусок кода, относящийся к запросу данных с сервера, и часть,
обеспечивающая возможность совместной работы остальных частей.

Начнём с наиболее простой части приложения — «понравившихся результатов». В
оригинальном приложении следующий код отвечал за обновление этого блока:

    var liked = $('#liked');
    var resultsList = $('#results');

    // …

    resultsList.on('click', '.like', function (e) {
      e.preventDefault();
      var name = $(this).closest('li').find('h2').text();
      liked.find( '.no-results' ).remove();
      $('<li>', { text: name }).appendTo(liked);
    });

«Поисковая выборка» переплетена с «понравившимся» и привязана к разметке.
Значительно лучше было бы создать для «понравившегося» отдельный объект,
который будет отвечать за работу с соответствующими узлами DOM.

    var Likes = function (el) {
      this.el = $(el);
      return this;
    };

    Likes.prototype.add = function (name) {
      this.el.find('.no-results').remove();
      $('<li>', { text: name }).appendTo(this.el);
    };

В этом коде приведён конструктор, создающий новую копию объекта Likes, который
будет обеспечивать работу «понравившегося». Созданная копия имеет метод `.add()`,
используемый для добавления новых результатов. Давайте напишем пару тестов,
которые будут проверять ее работоспособность:

    var ul;

    setup(function(){
      ul = $('<ul><li class="no-results"></li></ul>');
    });

    test('constructor', function () {
      var l = new Likes(ul);
      assert(l);
    });

    test('adding a name', function () {
      var l = new Likes(ul);
      l.add('Дмитрий Менделеев');

      assert.equal(ul.find('li').length, 1);
      assert.equal(ul.find('li').first().html(), 'Дмитрий Менделеев');
      assert.equal(ul.find('li.no-results').length, 0);
    });

Не так сложно, правда? Здесь используется [Mocha][7] в качестве *тестирующего*
фреймворка и [Chai][8] как дополнительная библиотека. Mocha обеспечивает
функции `test` и `setup`; Chai — функцию `assert`. Существует множество других
фреймворков для тестирования, но я считаю эти два достаточными для введения в
предметную область. Вам следует найти фреймворк, который подойдет для вас и
вашего проекта наилучшим образом. Кроме Mocha стоит обратить внимание на
достаточно популярный [Qunit][9] или подающий большие надежды [Intern][10].

Приведённый код начинается с создания элемента, который будет использован как
контейнер для «понравившегося». Затем запускается два теста: первый
проверяет, можем ли мы создать блок «понравившегося»; второй нужен, чтобы
удостовериться, что метод `.add()` работает корректно. С этими тестами
мы можем проводить рефакторинг кода и быть уверенными, что мы сразу узнаем
о возникновении ошибки.

Код нашего приложения теперь выглядит так:

    var liked = new Likes('#liked');
    var resultsList = $('#results');


    // …


    resultsList.on('click', '.like', function (e) {
      e.preventDefault();

      var name = $(this).closest('li').find('h2').text();

      liked.add(name);
    });

Код, отвечающий за формирование «поисковой выборки», сложнее, чем код, отвечающий
за «понравившееся», но давайте все же проведем его рефакторинг. Точно так же,
как мы создали метод `.add()` у Likes, мы создадим методы для работы с
«поисковой выборкой». Нам нужно иметь возможность добавлять новые результаты
в выборку и удобный способ оповещения других частей приложения о событиях,
возникающих при работе с «поисковой выборкой» — например, когда кому-то
понравился определенный ее элемент.

    var SearchResults = function (el) {
      this.el = $(el);
      this.el.on( 'click', '.btn.like', _.bind(this._handleClick, this) );
    };

    SearchResults.prototype.setResults = function (results) {
      var templateRequest = $.get('people-detailed.tmpl');
      templateRequest.then( _.bind(this._populate, this, results) );
    };

    SearchResults.prototype._handleClick = function (evt) {
      var name = $(evt.target).closest('li.result').attr('data-name');
      $(document).trigger('like', [ name ]);
    };

    SearchResults.prototype._populate = function (results, tmpl) {
      var html = _.template(tmpl, { people: results });
      this.el.html(html);
    };

Теперь код нашего старого приложения, отвечающий за взаимодействие между
«Поисковой выборкой» и «Понравившимся», выглядит так:

    var liked = new Likes('#liked');
    var resultsList = new SearchResults('#results'); 
 

    // …
  

    $(document).on('like', function (evt, name) {
      liked.add(name);
    })

Такой код намного проще, потому что мы используем `document` как глобальный
транспорт для сообщений, и, передавая данные через него, мы избавляем отдельные
части приложения от необходимости знать друг о друге. (В реальной жизни мы
использовали бы [backbone][11] или [RSVP][12] для управления событиями. В текущем
демонстрационном приложении мы запускаем события в `document` для упрощения кода).
Мы также спрячем всю рутинную работу — поиск имени понравившегося человека из
поисковой выдачи — внутри объекта поисковых результатов, чтобы не захламлять
им код приложения. Наконец, мы можем написать тесты, которые подтверждают, что
блок «поисковой выборки» работает корректно:

    var ul;
    var data = [ /* ненастоящие данные */ ];

    setup(function () {
      ul = $('<ul><li class="no-results"></li></ul>');
    });

    test('constructor', function () {
      var sr = new SearchResults(ul);
      assert(sr);
    });

    test('display received results', function () {
      var sr = new SearchResults(ul);
      sr.setResults(data);

      assert.equal(ul.find('.no-results').length, 0);
      assert.equal(ul.find('li.result').length, data.length);
      assert.equal(
        ul.find('li.result').first().attr('data-name'),
        data[0].name
      );
    });

    test('announce likes', function() {
      var sr = new SearchResults(ul);
      var flag;
      var spy = function () {
        flag = [].slice.call(arguments);
      };

      sr.setResults(data);
      $(document).on('like', spy);

      ul.find('li').first().find('.like.btn').click();

      assert(flag, 'event handler called');
      assert.equal(flag[1], data[0].name, 'обработчик события получил данные' );
    });

Кроме того, следует обратить внимание на код, отвечающий за взаимодействие с
сервером. Код содержит в себе прямой вызов `$.ajax()`, и обработчик этого
вызова работает напрямую с DOM:

    $.ajax('/data/search.json', {
      data : { q: query },
      dataType : 'json',
      success : function( data ) {
        loadTemplate('people-detailed.tmpl').then(function(t) {
          var tmpl = _.template( t );
          resultsList.html( tmpl({ people : data.results }) );
          pending = false;
        });
      }
    });

Повторюсь, что очень трудно писать модульные тесты для такого кода из-за того,
что слишком много вещей происходит всего в нескольких строчках кода. Мы можем
выделить данные приложения в самостоятельный объект:

    var SearchData = function () { };

    SearchData.prototype.fetch = function (query) {
      var dfd;

      if (!query) {
        dfd = $.Deferred();
        dfd.resolve([]);
        return dfd.promise();
      }

      return $.ajax( '/data/search.json', {
        data : { q: query },
        dataType : 'json'
      }).pipe(function( resp ) {
        return resp.results;
      });
    };

Теперь можно переписать код, отвечающий за вывод поисковой выборки на страницу:

    var resultsList = new SearchResults('#results'); 
    var searchData = new SearchData();

    // …

    searchData.fetch(query).then(resultsList.setResults);

Мы снова очень сильно упростили код нашего приложения, и вынесли все, что
представляло сложности, в объект `searchData` вместо того, чтобы оставить в
основном коде приложения. Кроме того, мы сделали наш поисковый интерфейс пригодным
для тестирования, впрочем, стоит помнить о некоторых особенностях, которые
возникают при тестировании кода, взаимодействующего с сервером.

Во-первых, это то, что нам *не нужно посылать серверу реальные запросы*, так как
это уже будет интеграционным тестированием, а так как мы с вами ответственные
разработчики, то код на стороне сервера уже покрыт всеми нужными тестами, верно?
Вместо этого нам нужно создать «заглушку», и мы можем сделать это с использованием
библиотеки [Sinion][13]. Во-вторых, нам необходимо протестировать неидеальные
ситуации — например, поведение приложения при отправке пустого запроса.

    test('constructor', function () {
      var sd = new SearchData();
      assert(sd);
    });

    suite('fetch', function () {
      var xhr, requests;

      setup(function () {
        requests = [];
        xhr = sinon.useFakeXMLHttpRequest();
        xhr.onCreate = function (req) {
          requests.push(req);
        };
      });

      teardown(function () {
        xhr.restore();
      });

      test('fetches from correct URL', function () {
        var sd = new SearchData();
        sd.fetch('cat');

        assert.equal(requests[0].url, '/data/search.json?q=cat');
      });

      test('вернуть promise', function () {
        var sd = new SearchData();
        var req = sd.fetch('cat');

        assert.isFunction(req.then);
      });

      test('нет ответа, если нет запроса', function () {
        var sd = new SearchData();
        var req = sd.fetch();
        assert.equal(requests.length, 0);
      });

      test('вернуть promise, даже если нет запроса', function () {
        var sd = new SearchData();
        var req = sd.fetch();

        assert.isFunction( req.then );
      });

      test('no query promise resolves with empty array', function () {
        var sd = new SearchData();
        var req = sd.fetch();
        var spy = sinon.spy();

        req.then(spy);

        assert.deepEqual(spy.args[0][0], []);
      });

      test('returns contents of results property of the response', function () {
        var sd = new SearchData();
        var req = sd.fetch('cat');
        var spy = sinon.spy();

        requests[0].respond(
          200, { 'Content-type': 'text/json' },
          JSON.stringify({ results: [ 1, 2, 3 ] })
        );

        req.then(spy);

        assert.deepEqual(spy.args[0][0], [ 1, 2, 3 ]);
      });
    });

Я оставила за пределами статьи рефакторинг объекта SearchForm и провела
рефакторинг еще нескольких участков кода и тестов. Если вам интересно, вы можете
взглянуть на законченную версию приложения в моём [репозитории][14] на github.

После того, как мы провели рефакторинг приложения согласно принципам написания
тестируемого кода, он стал значительно чище, чем был:

    $(function() {
      var pending = false;

      var searchForm = new SearchForm('#searchForm');
      var searchResults = new SearchResults('#results');
      var likes = new Likes('#liked');
      var searchData = new SearchData();

      $(document).on('search', function (event, query) {
        if (pending) { return; }

        pending = true;

        searchData.fetch(query).then(function (results) {
          searchResults.setResults(results);
          pending = false;
        });

        searchResults.pending();
      });

      $(document).on('like', function (evt, name) {
        likes.add(name);
      });
    });

Важнее того, что мы получили более аккуратный код, может быть только то, что он
превосходно покрыт модульными тестами. Это означает, что мы можем проводить
рефакторинг приложения и не бояться, что оно перестанет работать. Мы даже можем
написать дополнительные тесты, если появится такая необходимость, и код,
который будет их проходить.

## В долгосрочной перспективе тестирование облегчает нам жизнь

Несложно посмотреть на всё, что тут написано и спросить: «Подождите, вы хотите,
чтобы я написал больше кода, чтобы получить тот же самый результат?»

Дело в том что есть несколько бесспорных фактов о том, как обстоят дела при
разработке приложений для интернет. Сначала вы разработаете подход к решению
некоторой проблемы и реализуете его. Затем вы его протестируете, либо прокликав в
браузере, либо написав автоматизированные тесты, либо, **ох**, позволив
пользователю протестировать ваш код в продакшене. А после этого вы внесете в
код правки и позволите пользователям начать его использовать. И в нем будут
баги, не важно как тщательно вы его тестировали.

Все дело в том, что хотя использование тестов и требует больше времени на
написания кода вначале, оно экономит его в долгосрочной перспективе. Вы будете
хлопать в ладоши от радости, когда тесты покажут наличие ошибки до того, как
она попадет в продакшен и будете безмерно рады их наличию, когда тесты
подтвердят, что вы действительно исправили ошибку.


## Материалы для дальнейшего изучения

Эта статья только поверхностно описывает тестирование в JavaScript, но если вы
заинтересовались и хотите изучить тему глубже, то обратите внимание на следующие ссылки:

* [Моя презентация][15] с конференции Full Frontall (Брайтон, Великобритания, 2012);
* [Grunt][16] — инструмент, который поможет автоматизировать процесс тестирования;
* Книга [Test-Driven JavaScript Development][17] Кристиана Джохансона, создателя
библиотеки Sinion. Это краткая, но очень информативная проверка по основным
постулатам тестируемого JavaScript.

[1]: http://docs.seleniumhq.org/
[2]: https://github.com/jnicklas/capybara
[4]: https://twitter.com/ajpiano
[7]: http://visionmedia.github.io/mocha/
[8]: http://chaijs.com/
[9]: http://qunitjs.com/
[10]: http://theintern.io/
[11]: http://backbonejs.org
[12]: https://github.com/tildeio/rsvp.js
[13]: http://sinonjs.org/
[14]: https://github.com/rmurphey/testable-javascript
[15]: http://lanyrd.com/2012/full-frontal/sztqh/
[16]: http://gruntjs.com/
[17]: http://www.amazon.com/Test-Driven-JavaScript-Development-Developers-Library/dp/0321683919/ref=sr_1_1?ie=UTF8&qid=1366506174&sr=8-1&keywords=test+driven+javascript+development

[Поисковое приложение]: ./img/app.png "Поисковое приложение"
[Организация кода]: ./img/code-lines.png "Организация кода"
[Части приложения]: ./img/app-views.png "Части приложения"
